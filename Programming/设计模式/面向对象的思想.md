# 常用设计模式

## 面向对象的三大特性

* 封装

* 继承

* 多态 (允许一个接口，调用不同的类或对象)，有两种实现方式：比如可以用方法重载来实现，也可以用子类继承实现

  * 方法重载（overloading）：方法重载是指在同一类中定义多个具有相同名称但参数列表不同（参数的个数或类型）的方法。编译器会根据调用时所传递的参数类型自动选择合适的实现。例如，Python中的多态（基于鸭子类型）：在这个例子中，`Dog`和`Cat`类都有一个`speak`方法。尽管它们属于不同的类，但可以使用相同的接口（函数`make_sound`）调用`speak`方法。这就是多态的体现。

    * ```
      class Dog:
          def speak(self):
              return "Woof!"
      
      class Cat:
          def speak(self):
              return "Meow!"
      
      def make_sound(animal):
          print(animal.speak())
      
      dog1 = Dog()
      cat1 = Cat()
      
      # 使用相同的接口调用不同的对象
      make_sound(dog1)  # 输出：Woof!
      make_sound(cat1)  # 输出：Meow!
      
      ```

  * 上述示例，也是python对鸭子类型支持的一个很好的示例。

  * 鸭子类型（duck typing）是一种在动态类型语言（例如Python）中实现多态的编程概念。这个概念的名字来自于著名的说法：“如果它走起来像鸭子，叫起来像鸭子，那么它就是鸭子。”在编程语境下，鸭子类型关注的是对象的行为（也就是它所具备的属性和方法），而非其确切的类型。

    在鸭子类型的编程风格中，开发者通常不会进行显式的类型检查。相反，他们依赖对象所表现出的行为特点。只要对象能够支持所需的操作，那么它就被视为具有相应的类型。换句话说，对象的类型由其所具备的方法和属性决定，而非其继承的类或实现的接口。

    在这个例子中，`Dog`和`Cat`类都具有一个名为`speak`的方法。虽然这两个类之间没有继承关系或共享接口，但它们都满足`make_sound`函数的要求——拥有一个可以被调用的`speak`方法。通过鸭子类型，我们可以用相同的接口（函数`make_sound`）来调用这两个类的`Dog`和`Cat`对象，实现多态。

    鸭子类型为编程带来了灵活性，但也有一定的风险——如程序在运行时才能发现类型错误。为了降低这种风险，开发者需要确保代码易于理解并且编写相应的单元测试。

  * 多数动态语言都支持鸭子类型，比如python，Ruby，JavaScript，PHP

## 反射

python 可以通过反射实现动态导包，默认的import xxx后面的xxx不能是string，但可以用 \_\_import\_\_("xxx")的方法来实现导入

## 面向对象的 SOLID

S: 单一职责原则：不要存在多个导致类变更的原因，通俗的讲，一个类只干一件事。  
O (Open Close Principal): 开放封闭原则：一个软件实体如类，模块和函数，应该对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展

L：李氏替换原则： 所有使用父类的地方，必须能透明的使用其子类对象。（引用父类对象的时候，输入的参数和返回值，要和引用子类对象的参数和返回值一样）

I: 依赖倒置原则：高层模块(业务的直接实现)不应该依赖底层模块(为实现业务而定义的类)，二者都应该依赖其抽象（抽象指的是接口），抽象不应该依赖细节，细节应该依赖抽象。换言之，要针对接口编程，而不是针对其实现编程

D：接口隔离原则：使用多个专门的接口，而不要使用单一的总接口，即类的实例化的对象，所调用的类应该只有其需要的方法。

